### 챕터 10요약


### 이 장의 목표
- 가상 메모리를 정의하고 그 이점을 설명한다.
- 요구 페이징을 사용하여 페이지가 메모리에 적재되는 방법을 설명한다.
- Linux, Windows 10 및 Solaris가 가상 메모리를 관리하는 방법을 설명한다.
- C 프로그래밍 언어로 가상 메모리 관리자 시뮬레이션을 설계한다

## 10.1 배경
프로그램 전체가 한꺼번에 메모리에 늘 올라와야하지는 않다..
- 잘 발생하지 않는 오류 상황을 처리하는 코드들은 거의 실행되지 않는다.
- 배열(arrays) 리스트(lists) 테이블(table)등은 필요 이상으로 많은 공간을 점유할 수도 있다.
- 프로그램 내 어떤 옵션(option)이나 기능들을 거의 사용되지 않는다, 또한 전체 프로그램이 필요한 경우에도 그 프로그램의 모든 부분이 모두 동시에 요구되지 않을 수 있다.

만약 프로그램을 일부분만 메모리에 올려놓고 실행할 수 있다면 다음과 같은 많은 이점이 있다..
- 프로그램은 물리 메모리 크기에 의해 더는 제약받지 않는다. 사용자들은 매우 큰 가상 주소 공간을 가정하고 프로그램을 만들 수 있기 때문에 프로그래밍 작업이 간단해진다.
- 각 프로그램이 더 작은 메모리를 차지하므로 더 많은 프로그램을 동시에 수행할 수 있다. 이에 따라 응답 시간(response time)은 늘어나지 않으면서도 CPU 이용률(utilization)과 처리율(throughput)이 높아진다.
- 프로그램을 메모리에 올리고 스왑(swap)하는데 필요한 I/O회수가 줄어들기 때문에 프로그램이 보다 빨리 실행된다

**가상 메모리**는 실제의 물리 메모리 개념과 개발자의 논리 메모리 개념을 분리한 것이다(그림 10.1).
한 프로세스의 **가상 주소 공간**은 그 프로세스가 메모리에 저장되는 논리적인 모습(view)를 말한다(그림 10.2).
*힙(heap)* 은 동적 할당 메모리를 사용함에 따라 주소 공간상에서 위쪽으로 확장된다. 비슷한 방식으로 *스택(stack)* 은 함수 호출을 거듭함에 따라 주소 공간상에서 아래쪽으로 확장된다.
힙과 스택 사이의 공백도 가상 주소 공간의 일부이지만, 힙 또는 스택이 확장되어야만 실제 물리 페이지를 요구하게 될 것이다.
공백을 포함하는 가상 주소 공간을 *성긴(sparse)* 주소 공간이라 한다. 성긴 주소 공간의 공백은 스택이나 힙 세그먼트가 확장될 때 사용되거나 프로그램 실행 중 동적으로 라이브러리를 링크할 필요가 있을 때 사용된다.
가상 메모리는 또한 페이지 공유를 통해 파일이나 메모리가 둘 또는 그 이상의 프로세스들에 의해 공유되는 것을 가능하게 해주는데, 여기서 오는 장점은 다음과 같다.
- 표준 C 라이브러리와 같은 시스템 라이브러리가 여러 프로세스들에 공유될 수 있다. 각 프로세스는 라이브러리가 자신의 가상 주소 공간 일부라고 생각하지만, 실제로는 라이브러리가 존재하는 물리 메모리 페이지들은 모든 프로세스에 공유되고 있다(일반적으로 읽기만이 허용되는 상태).
- 프로세스들이 메모리를 공유할 수 있다. 가상 메모리는 한 프로세스가 다른 프로세스와 공유할 수 있는 영역을 만들 수 있도록 해 준다.
- 페이지는 fork() 시스템 콜을 통한 프로세스 생성 과정 중에 공유될 수 있기 때문에 프로세스 생성 속도를 높일 수 있다.
<br>

## 10.2 요구 페이징
**요구 페이징(demand paging)** 전략은, 프로그램 실행시 필요한 페이지만 메모리로 적재하는 것이다. 따라서 접근되지 않은 페이지는 물리 메모리로 적재되지 않는다.
- **기본 개념**
결과적으로 프로세스가 실행되는 동안 일부 페이지는 메모리에 있고 일부 페이지는 보조저장장치에 있다. 이 둘을 구별하기 위해 9.3.3절에서 사용한 유효/무효(valid-invaild) 비트 기법이 사용될 수 있다(그림 10.4).
만일 프로세스가 메모리에 올라와 있지 않은 페이지에 접근하려 하면 **페이지 폴트 트랩(page-fault trap)** 을 발생시킨다(그림 10.5).
페이지 폴트는 다음과 같이 처리된다.
	1. 프로세스에 대한 내부 테이블(internal table)[일반적으로 프로세스 제어 블록(PCB)와 함께 유지]을 검사해 해당 메모리 참조(reference)가 유효한지를 알아낸다.
	2. 무효한 페이지에 대한 참조라면 프로세스는 중단된다. 유효한 참조이고, 	페이지가 아직 메모리에 올라오지 않았다면, 그것을 보조기억장치로부터 가져와야 한다.
	3. 빈 공간(가용 프레임 free frame)을 찾는다.
	4. 보조저장장치에 새로이 할당된 프레임으로 해당 페이지를 읽어 들이도록 요청한다.
	5. 보조저장장치 읽기가 끝나면, 이 페이지가 이제는 메모리에 있다는 것을 알리기 위해 페이지 테이블을 갱신하며, 프로세스가 유지하고 있는 내부 테이블을 수정한다.
	6. 트랩에 의해 중단되었던 명령어를 다시 수행한다.

일단 필요한 모든 페이지가 적재되고 나면 더 폴트가 발생하지는 않는다. 이것이 **순수 요구 페이징(pure demand paging)**, 어떤 페이지가 필요해지기 전까지 결코 그 페이지를 메모리로 적재하지 않는 방법이다. 프로그램들은 한 명령어에서도 여러 개의 페이지 폴트를 일으킬 수도 있지만(이 경우 시스템 성능의 저하를 초래할 수 있다.). 다행히 이런 경우는 거의 발생하지 않는다.
10.6.1절에 기술된 바와 같이 **참조의 지역성(locality of reference)** 라고 불리는, 프로그램의 어느 한 특정 작은 부분만 한동안 집중적으로 참조하는 성질 덕에 요구 페이징은 만족할 만한 성능을 보인다. 요구 페이징을 지원하기 위해 필요한 하드웨어는 페이징과 스와핑을 위한 하드웨어와 동일하다.
- *페이지 테이블*: 보호 비트(protection bit)들 특별한 값 또는 유효/무효 비트를 통해 특정 항목을 무효로 설정할 수 있어야 한다.
- *보조저장장치(secondary memory)*: 메인 메모리에 없는 모든 페이지를 가지고 있다. 보통은 고성능의 디스크 또는 NVM 장치이다(스왑 장치라고도 한다).
<br>

- **가용 프레임 리스트**
페이지 폴트를 해결하기 위해 대부분의 운영체제는 이러한 요청을 충족시키기 위해 사용하기 위한 가용 프레임의 풀인 **가용 프레임 리스트**를 유지한다(그림 10.6).
시스템이 시작되면 모든 가용 메모리가 가용 프레임 리스트에 넣어진다. 가용 프레임이 요청되면(요구 페이징 등) 가용 프레임 리스트의 크기가 줄어든다.
<br>

- **요구 페이징의 성능**
요구 페이지 메모리에 대한 **실질 접근 시간**을 계산하기 위해 페이지 폴트의 처리 수순을 알아보자
1. 운영체제에 트랩을 요청한다.
2. 레지스터들과 프로세스 상태를 저장한다.
3. 인터럽트 원인이 페이지 폴트임을 알아낸다.
4. 페이지 참조가 유효한지 확인하고, 보조저장장치에 있는 페이지의 위치를 알아낸다.
5. 저장장치에 가용 프레임으로의 읽기 요구를 낸다
	1. 읽기 차례가 돌아오기까지 대기 큐에서 기다린다.
	2. 디스크에서 찾는(seek) 시간과 회전 지연 시간 동안 기다린다.
	3. 가용 프레임으로 페이지 전송을 시작한다.
6. 기다리는 동안엥 CPU 코어는 다른 사용자에게 할당된다.
7. 저장장치가 다 읽었다고 인터럽트를 건다(I/O 완료).
8. 다른 프로세스의 레지스터들과 프로세스 상태를 저장한다(6단계가 실행되었을 경우).
9. 인터럽트가 보조저장장치로부터 왔다는 것을 알아낸다.
10. 새 페이지가 메모리로 올라왔다는 것을 페이지 테이블과 다른 테이블들에 기록한다.
11. CPU코어가 자기 체례로 오기까지 다시 기다린다.
12. CPU 차례가 오면 위에서 저장시켜 두었던 레지스터들, 프로세스 상태, 새로운 페이지 테이블을 복원시키고 인터럽트 되었던 명령어를 다시 실행한다.

어떤 경우에도, 페이지 폴트 처리 시간은 **1.인터럽트의 처리, 2.페이지 읽기, 3.프로세스 재시작** 3개의 주요 작업 요소로 이루어져 있다.

## 10.3 쓰기 시 복사
`fork()`시스템 콜을 통해 프로세스를 생성할 때는 페이지 공유와 비슷한 기법으로 첫 요구 페이징조차 생략하는 것이 가능하다.
`fork()`는 부모 프로세스와 똑같은 자식 프로세스를 만들어 준다. 그렇지만 대부분의 자식은 만들어지마자 곧 `exec()`시스템 콜을 불러 부모로부터 복사해온 페이지들을 쓸모없게 한다.
그래서 부모의 페이지들을 다 복사해오는 대신 **쓰기 시 복사(copy-on-write)** 방식을 사용할 수 있다. 이 방식에서는 자식 프로세스가 시작할 때 부모의 페이지를 당분간 함께 사용하도록 한다.
Linux, macOS 및 BSD UNIX를 포함한 일부 운영체제들은 `vfork()(virtual memory fork)`라는 시스템 콜을 제공하고 있다.
`vfork()`를 하면 부모 프로세스는 보류되고 자식이 부모의 주소 공간을 사용하게 된다. `vfork()`는 자식이 만들어지자마자 `exec()`를 하는 경우를 위해 만들어졌다. 페이지가 전혀 복사되지 않기 때문에 매우 효율적이며 UNIX 명령어 해석기인 shell 구현 시에도 사용한다.
<br>

## 10.4 페이지 교체
전체 10페이지 중 실제 5페이지만을 사용하는 프로세스가 있다면, 요구 페이징을 통해 전혀 사용되지 않을 5페이지를 적재하는데 필요한 I/O를 피할 수 있다.
다중 프로그래밍 정도를 더 올리면, **메모리 과할당(over-allocating)** 이 발생한다(특정 상황에 프로세스들이 페이지를 더 요구해 가용 가능 페이지가 부족한 경우).
더욱이 시스템 메모리는 프로그램 페이지 말고도 많은 영역에서 메모리가 사용된다.
이 시점에서 운영체제는 몇 가지 선택을 할 수 있다. 프로세스를 종료하거나 표준 스와핑을 통해 프로세스를 스왑아웃 하여 모든 프레임을 비우고 다중 프로그래밍 정도를 줄일 수 있다.
그러나 위의 방법들은 메모리와 스왑 공간 사이에 전체 프로세스를 복사하는 오버헤드로 인해 대부분의 운영체제에서 표준 스와핑이 더는 사용되지 않는다.
대부분의 운영체제는 이제 이 절의 나머지 부분에서 자세히 설명하는 기법인 페이지 스와핑과 페이지 교체를 결합한다.

- **기본적인 페이지 교체**
만약 빈 프레임이 없다면 현재 사용되고 있지 않는 프레임을 찾아서 그것을 비워버린다. 그 프레임의 내용을 스왑 공간에 쓰고 그 페이지가 메모리에 이제는 존재하지 않는다는 것을 나타내기 위해, 페이지 테이블(모든 다른 테이블들)을 변화시킴으로써 프레임을 비워 있게 한다(그림 10.10). 페이지 폴트 서비스 루틴이 페이지 교체를 포함하여 다음과 같이 수정되어야 한다.
1. 보조저장장치에서 필요한 페이지의 위치를 알아낸다.
2. 빈 페이지 프레임을 찾는다.
	1. 비어있는 프레임이 있다면 그것을 사용한다.
	2. 비어있는 프레임이 없다면 *희생될(victim)* 프레임을 선정하기 위하여 페이지 교체 알고리즘을 가동시킨다.
	3. 희생될 페이지를 보조저장장치에 기록하고(필요한 경우), 관련 테이블을 수정한다.
3. 빼앗은 프레임에 새 페이지를 읽어오고 테이블을 수정한다.
4. 페이지 폴트가 발생한 지점에서부터 프로세스를 계속한다.
빈 프레임이 없는 경우에는 **디스크를 두번(프레임을 비울 때/읽어들일 때) 접근**해야 한다. 이러한 상황에서는 **페이지 폴트 처리 시간(page fault service time)** 이 2배 소요되며 그에 따라 실질 접근 시간도 증가한다.
이러한 오버헤드는 **변경 비트(modify bit/dirty bit)** 를 사용해 감소시킬 수 있다. 각 페이지나 프레임은 그것과 관련된 변경 비트를 하드웨어에 가지게 된다. 변경 비트는 CPU가 페이지 내의 어떤 바이트라도 쓰게 되면 페이지가 변경되었음을 나타내기 위해 설정된다.
요구 페이징 시스템은 **프레임 할당(frame-allocation)알고리즘**과 **페이지 교체(page-replacement)알고리즘** 두 문제를 해결해야 한다.
여러 프로세스가 존재하는 경우 각 프로세스에 얼마나 많은 프레임을 할당해야 할지 결정해야 한다. 또 페이지 교체가 필요할 때마다 어떤 페이지를 교체해야 할지 결정해야 한다.

- **FIFO 페이지 교체**
가장 간단한 페이지 교체 알고리즘으로, 메모리에 올라온지 가장 오래된 페이지를 내쫒는다. 이해하기 쉽고 구현도 쉽지만 성능이 항상 좋지는 않다.
	> Belady의 모순(Belady's anomaly): 프로세스에 프레임을 더 주었는데 오히려 페이지 폴트율은 더 **증가**하게 되는 현상.

- **최적 페이지 교체**
Belady의 모순이 가져온 결과중 하나는 **최적 교체 정책** 에 대한 탐색이다. 그러한 정책은 존재했고 OPT또는 MIN으로 불렸다.
안타깝게도 이 알고리즘은 프로세스가 앞으로 메모리를 어떻게 참조할 것인지를 미리 알아야 하기 때문에 구현이 어렵다.

- **LRU 페이지 교체**
최근의 과거를 가까운 미래의 근사치로 본다면 가장 오랜 기간 동안 *사용되지 않은* 페이지를 교체할 수 있다. 이 기법이 **least-recently-used (LRU) 알고리즘**이다.
LRU 페이지 교체 알고리즘은 하드웨어의 지원이 필요하다. 프레임들을 최근 사용된 시간 순서로 파악할 수 있어야 하기 때문이다. 두 가지의 구현 방법이 있다.
	- 계수기(counter): 각 페이지 항목마다 사용 시간 필드를 넣고 CPU에 논리적인 시계나 계수기를 추가한다. 각 페이지의 마지막 참조 시간을 알 수 있게 되면 시간 값이 가장 작은 페이지가 교체된다. 이 기법은 LRU페이지를 찾기 위해 페이지 테이블을 탐색하여야 하며, 메모리 참조 때마다 메모리 쓰기 작업을 필요로 한다.
	- 스택(stack): 페이지가 참조될 때마다 페이지 번호는 스택 중간에서 제거되어 스택 꼭대기(top)에 놓이게 된다. 이 방식을 적용하면 top에는 항상 최근에 사용된 페이지가 위치하고, bottom은 가장 오랫동안 이용되지 않은 페이지가 위치하게 된다. 매 갱신 시에는 약간 더 오버헤드가 크지만 교체갈 일어날 경우 페이지를 탐색할 필요가 없게 된다.

- **LRU 근사 페이지 교체**
많은 시스템은 참조 비트(reference bit)를 지원한다는 점에서 착안, 프로세스가 실행되면서 참조되는 페이지의 참조 비트는 하드웨어가 1로 세팅한다. 일정 시간 뒤에 어떤 페이지가 사용되었는지 여부를 알 수 있다.
	- 부가적 참조 비트 알고리즘: 일정한 간격마다 참조 비트들을 기록함으로서 추가적인 선후 관계 정보를 얻을 수 있다.
	- 2차 기회 알고리즘: FIFO에서 응용되었다. 페이지가 선택될 때마다 참조 비트를 확인해 0이면 페이지를 교체하고 1이면 다시 한번 기회를 주고 다음 FIFO페이지로 넘어간다. 순환 큐를 이용하여 2차 기회 알고리즘을 구현할 수 있다(그림 10.17).
	- 개선된 2차 기회 알고리즘: 변경 비트까지 2개의 비트를 조합하면 네 가지의 등급으로 나눌 수 있다.
		1. 00: 최근에 사용되지도 변경되지도 않은 경우 - 교체하기에 가장 좋은 페이지
		2. 01: 최근에 사용되지는 않았지만 변경은 된 경우 - 해당 페이지는 뺏어 오려면 디스크에 내용을 기록해야 하기 때문에 교체에 적합하지 않다.
		3. 10: 최근에 사용은 되었으나 변경은 되지 않은 경우 - 이 페이지는 곧 다시 사용될 가능성이 높다.
		4. 11: 최근에 사용도 되었고 변경도 된 경우 - 곧 다시 사용될 것이며 뺏으려면 디스크에 그 내용을 먼저 기록해야 한다..

- **계수-기반 페이지 교체**
각 페이지를 참조할 때마다 계수를 하게 만들면 두 가지의 기법을 만들 수 있다. 일반적으로 잘 쓰이지는 않는다(구현하는데 비용이 많이 들고 최적 페이지 교체 정책을 제대로 근사하지 못하기 때문).
	- LFU 알고리즘: **LFU(least frequently used)**알고리즘은 참조 횟수가 가장 작은 페이지를 교체하는 방법이다.
	- MFU 알고리즘: **MFU(most frequently used)**알고리즘은 가장 작은 참조 회수를 가진 페이지가 가장 최근 참조된 것이고 앞으로 사용될 것이라는 판단에 근거된 기법이다.

- **페이지-버퍼링 알고리즘**
시스템들이 가용 프레임 여러 개를 풀(pool)로 가지고 있다가, 페이지 폴트가 발생하면 예전과 마찬기지로 교체될 페이지를 찾지만, 교체될 페이지의 내용을 디스크에 기록하기 전에 가용 프레임에 새로운 페이지를 먼저 읽어 들이는 방법이다.

- **응용과 페이지 교체**
<br>

## 10.5 프레임의 할당

- **최소로 할당해야 할 프레임의 수**
최소한의 프레임은 할당해야만 하는 한 가지 이유는 성능과 관계된다. 각 프로세스에 할당되는 프레임 수가 줄어들면 페이지 폴트율은 증가하고 프로세스 실행은 늦어지게 된다. 또한 명령어 수행이 완료되기 전에 페이지 폴트가 발생하면 그 명령어는 재실행되어야 한다. 따라서 하나의 명령어가 참조하는 모든 페이지는 동시에 메모리에 올라와 있어야 그 명령어의 수행이 끝날 수 있다.
최소 프레임 수는 컴퓨터 아키텍처에 의해 정의된다.

- **할당 알고리즘**
프로세스에게 똑같은 양을 할당하는 **균등 할당(equal allocation)** 과 가용 메모리를 각 프로세스의 크기 비율에 맞추어 할당하는 **비례 할당(proportional allocation)**이 있다.

- **전역 대 지역 할당**
전역 교체(global replacement): 프로세스가 교체할 프레임을 다른 프로세스에 속한 프레임을 포함한 모든 프레임을 대상으로 찾는 경우. 프로세스의 메모리에 있는 페이지 집합이 해당 프로레스의 페이징 동작뿐만 아니라 다른 프로세스의 페이징 동작에도 영향을 줄 수 있다는 단점이 있다.
지역 교체(loacl replacement): 프로세스가 자기에게 할당된 프레임 중에서만 교체될 희생자를 선택할 수 있는 경우. 자신의 할당된 프레임만 고려할 수 있기 때문에 우선순위가 낮은 다른 프로세스의 프레임을 뺏어올 수 없다는 단점이 있다.

- **비균등 메모리 접근**
<br>
