**교착 상태**: 대기 중인 스레드들이(그들이 요청한 자원들이 다른 스레드들에 의해서 점유되어 있고 그들도 다 대기 상태에 있기 때문에) 결코 다시는 그 상태를 변경시킬 수 없는 상황
### 이 장의 목표
- Mutex 락을 사용할 때 어떻게 교착 상태가 발생할 수 있는지 보여 준다.
- 교착 상태를 특징 짓는 4가지 필수 조건을 정의한다.
- 자원 할당 그래프에서 교착 상태 상황을 식별한다.
- 교착 상태 예방을 위한 4가지 방법을 평가한다.
- 교착 상태 회피를 위해 은행의 알고리즘을 적용한다.
- 교착 상태 감지 알고리즘을 적용한다.
- 교착 상태에서 복구하기 위한 접근법을 평가한다.

## 8.1 시스템 모델 System Model
시스템은 경쟁하는 스레드들 사이에서 분배되어야 할 유한한 수의 자원들로 구성된다.
스레드는 자원을 사용하기 전에 반드시 요청해야 하고, 사용 후에는 반드시 방출해야 한다.
정상적인 작동 모드하에서, 프로세스는 다음 순서로만 자원을 사용할 수 있다.
1. 요청: 스레드는 자원을 요청한다. 요청이 즉시 허용되지 않으면(mutex락을 다른 스레드가 가지고 있는 경우), 요청 스레드는 자원을 얻을 때까지 대기해야 한다.
2. 사용: 스레드는 자원에 대해 작업을 수행할 수 있다(자원이 mutex 락이라면, 스레드는 자신의 임계구역에 접근할 수 있다).
3. 방출: 스레드가 자원을 방출한다.

## 8.2 다중 스레드 응용에서의 교착 상태 Deadlock in Multithreaded Applications

- **라이브락 Livelock**
	또 다른 형태의 라이브니스 장애, 교착 상태와 유사하나 진행할 수 없는 이유가 서로 다르다.
	라이브락은 스레드가 실패한 행동을 계속해서 시도할 때 발생한다.
	pthread_mutex_trylock()함수로 설명가능하다. 이 함수는 봉쇄되지 않고 mutex락을 획득하려고 시도한다. 락을 얻는데 실패할 작업을 동시에 재시도할 때 라이브락이 발생한다.
	일반적으로 각 스레드가 실패한 행동을 재시도하는 시간을 무작위로 정하면 회피할 수 있다. 네트워크 충돌이 발생할 때 Ethernet네트워크가 취하는 방법이기도 하다.

## 8.3 교착 상태 특성 Deadlock Characterization

- **필요조건들 Necessary Conditions**
교착 상태는 한 시스템에 다음 네 가지 조건이 동시에 성립될 때 발생될 수 있다.
	1. **상호 배재**(mutual exclusion): 최소한 하나의 자원이 비공유 모드로 점유되어야 한다. 비공유 모드에서는 한 번에 한 스레드만이 그 자원을 사용할 수 있다. 다른 스레드가 그 자원을 요청하면, 요청 스레드는 자원이 방출될 때까지 반드시 지연되어야 한다.
	2. **점유하며 대기**(hold-and-wait): 스레드는 최소한 하나의 자원을 점유한 채, 현재 다른 스레드에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기해야 한다.
	3. **비선점**(no preemption): 자원들을 선점할 수 없어야 한다. 즉, 자원이 강제적으로 방출될 수 없고, 점유하고 있는 스레드가 태스크를 종료한 후 그 스레드에 의해 자발적으로만 방출될 수 있다.
	4. **순환 대기**(circular wait): 대기하고 있는 스레드의 집합[T0, T1, ..., Tn]에서 T0는 T1이 점유한 자원을 대기하고, T1은 T2가 점유한 자원을 대기하고, ..., Tn-1은 Tn이 점유한 자원을 대기하며, Tn은 T0가 점유한 자원을 대기한다.

교착 상태가 발생하려면, 위의 네 가지 조건이 성립되어야 함을 강조한다.
<br>

- **자원 할당 그래프 Resource-Allocation Graph**
교착 상태는 **시스템 자원 할당 그래프**라고 하는 방향 그래프로 더욱 정확하게 기술할 수 있다. 이 그래프는 정점(vertex) V의 집합과 간선(edge) E의 집합으로 구성된다.
정점 V의 집합은 시스템 내의 모든 활성 스레드의 집합인 T = {T1, T2, ..., Tn}과 시스템 내의 모든 자원 유형의 집합인 R = {R1, R2, ..., Rm}의 두 가지 유형으로 구분된다.
스레드 Ti로부터 자원 유형 Rj로의 방향 간선(directed edge)은 Ti -> Rj로 표현하며, 이것은 스레드 Ti가 자원 유형 Rj의 인스턴스를 하나 요청하는 것으로 현재 이 자원을 기다리는 상태이다. (요청 간선)
자원 유형 Rj로부터 스레드 Ti로의 방향 간선은 Rj -> Ti로 표현하며, 이것은 자원 유형 Rj의 한 인스턴스가 스레드 Ti에 할당된 것을 의미한다. (할당 간선)
자원 할당 그래프에 사이클이 없다면, 시스템은 교착 상태가 아니다. 사이클이 있다면, 교착 상태일 가능성이 있다.

## 8.4 교착 상태 처리 방법 Methods for Handling Deadlocks
교착 상태 문제를 처리하는 세 가지 방법
- 문제를 무시하고, 교착 상태가 시스템에서 절대 발생하지 않는 척한다..(?)
- 시스템이 결코 교착 상태가 되지 않도록 보장하기 위하여 교착 상태를 예방하거나 회피하는 프로토콜을 사용한다.
- 시스템이 교착 상태가 되도록 허용한 다음에 복구시키는 방법이 있다.

첫 번째 해결안이 Linux와 Windows를 포함해 대부분의 운영체제가 사용하는 방법이다. 이렇다면 교착 상태를 처리하는 프로그램을 작성하는 것은 응용 개발자의 몫이 된다.

교착 상태가 발생하지 않도록 하기 위해 시스템은 교착 상태 예방(prevention), 혹은 회피(avoidence)기법의 하나를 사용할 수 있다.
- 교착 상태 예방: 교착 상태의 필요조건 중 적어도 하나가 성립되지 않도록 하는 방법
- 교착 상태 회피: 스레드가 평생 요구하고 사용할 자원에 대한 부가적인 정보를 미리 제공하는 것. 이 정보를 가지고 운영체제는 각 요청을 위해 그 스레드가 기다려야 할지의 여부를 판단한다.

만약 위 방법들을 사용하지 않고 교착 상태가 발생하게 되면, 시스템은 교착 상태가 발생했는지 여부를 확인하는 알고리즘과 교착 상태에서 복구하기 위한 알고리즘을 제공할 수 있다.

## 8.5 교착 상태 예방 Deadlock Prevention

- **상호 배재 Mutual Exclusion**
	적어도 하나의 자원은 공유가 불가능한 자원이어야 한다.
- **점유하며 대기 Hold and Wait**
	스레드가 자원을 요청할 때마다 다른 자원을 보유하지 않도록 보장해야 한다. 한 대안 프로토콜은 스레드가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 허용한다.
	자원이 할당되었지만 장기간 사용되지 않을 수 있기 때문에 자원이용률이 낮을 수 있고 기아가 발생할 수 있다는 단점이 있다.
- **비선점 No Preemption**
	이미 할당된 자원이 선점되지 않아야 한다.
- **순환 대기 Circular Wait**
	위 세 가지 옵션은 대부분의 상황에서 일반적으로 실용적이지 않다. 하지만 순환 대기 조건은 실용적인 해결책을 제공할 수 있는 기회를 제공한다.
	모든 자원 유형에 전체적인 순서를 부여하여, 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 요구하는 것이다.

## 8.6 교착 상태 회피 Deadlock Avoidance
교착 상태 예방 알고리즘의 부수적인 문제는 장치의 이용률이 저하되고 시스템 총처리율(throughput)이 감소한다는 것이다.
교착 상태를 회피하는 다른 대안은 자원이 어떻게 요청될지에 대한 추가 정보를 제공하도록 요구하는 것이다.
시스템은 현재 요청이 충족되 수 있는지 또는 반드시 대기해야 할 것인지를 결정하기 위해, 현재 가용 자원, 현재 각 스레드에 할당된 자원, 그리고 각 스레드가 앞으로 요청하거나 방출할 자원을 고려해야 한다.
가장 단순한 모델은 각 스레드가 자신이 필요로 하는 각 유형의 자원마다 최대 수를 선언하도록 요구하는 것이다. 이 정보를 미리 알 수 있다면, 우리는 시스템이 교착 상태에 들어가지 않을 것을 보장하는 알고리즘을 만들 수 있다.
교착 상태 회피 알고리즘은 순환 대기 상황이 발생하지 않도록 자원 할당 상태를 검사한다. 자원 할당 상태는 가용 자원의 수, 할당된 자원의 수 그리고 스레드들의 최대 요구 수에 의해 정의된다.

- **안전 상태 Safe State**
	시스템 상태가 안전하다는 말은 시스템이 어떤 순서로든 스레드들이 요청하는 모든 자원을(최대 요구 수를 요구하더라도) 교착 상태를 야기시키지 않도 차례로 모두 할당해 줄 수 있다는 것을 뜻한다.

- **은행원 알고리즘 Banker's Algorithm**
	이 시스템에서는 스레드가 시작할 때 스레드가 가지고 있어야 할 자원의 최대 개수를 자원 종류마다 미리 신고하여야 한다.
