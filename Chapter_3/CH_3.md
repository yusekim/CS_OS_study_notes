## 3.1 프로세스 개념 Process Concept

- **프로세스**
	프로세스의 현재 활동의 상태는 프로그램 카운터 값과 프로세서 레지스터의 내용으로 나타낸다.
	프로세서의 메모리 배치
	- 텍스트 섹션: 실행 코드
	- 데이터 섹션: 전역 변수
	- 힙 섹션: 프로그램 실행 중에 동적으로 할당되는 메모리
	- 스택 섹션: 함수를 호출할 때 임시 데이터 저장장소(함수 매개변수, 복귀 주소 및 지역 변수)
	텍스트 및 데이터 섹션의 크기는 고정, 스택 및 힙 섹션은 프로그램 실행 중에 동적으로 줄어들거나 커질 수 있다.
	할수가 호출될 때마다 함수 매개변수, 지역 변수 및 복귀 주소를 포함하는 **활성화 레코드(activation record)** 가 스택에 푸쉬 된다. 함수에서 제어가 되돌아오면 스택에서 활성화 레코드가 팝 된다.
	<u>스택 및 힙 섹션이 서로의 방향으로 커지더라도 운영체제는 서로 겹치지 않도록 노력해야 한다.</u>
	프로그램은 명령어 리스트를 내용으로 가진 디스크에 저장된 파일(실행 파일)과 같은 **수동적인(passive entity)** 존재이다(프로세스가 아니다!).
	프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터와 관련 자원의 집합을 가진 **능동적인(active entity)** 이다.
	_실행 파일이 메모리에 적재될 때 프로그램은 프로세스가 된다._
<br>

- **프로세스 상태 Process State**
	프로세스는 실행되며 그 상태가 변한다.
	- 새로운(new): 프로세스가 생성 중이다.
	- 실행(running): 명령어들이 실행 중이다.
	- 대기(waiting): 프로세스가 어떤 이벤트(입출력, 신호 등등)를 대기한다.
	- 준비(ready): 프로세스가 처리기에 할당되기를 기다린다.
	- 종료(terminated): 프로세스의 실행이 종료되었다.
<br>

- **프로세스 제어 블록 Process Control Block**
	각 프로세스는 운영체제에서 프로세스 **제어 블록(테스크 제어 블록이라고도 불림)**에 의해 표현된다. 프로세스 제어 블록은 특정 프로세스와 연관된 여러 정보를 수록하며, 다음과 같은 것들을 포함한다.
	- 프로세스 상태: 새로운, 실행, 대기, 준비, 종료 등
	- 프로그램 카운터: 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.
	- CPU 레지스터들: 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터들과 상태 코드 정보가 포함된다. 나중에 프로세스가 다시 슼케줄 될 때 계속 올바르게 실행되도록 하기 위해서 인터럽트 발생 시 저장되어야 한다.
	- CPU-스케줄링 정보: 이 정보는 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수를 포함한다.
	- 메모리 관리 정보: 운영체제에 사용되는 메모리 시스템에 따라 기준(base) 레지스터와 한계(limit)레지스터의 값, 운영체제가 사용하는 메모리 시스템에 따라 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함한다.
	- 회계 정보: CPU 사용시간, 경과된 실시간, 시간 제한, 계정 정보, 잡 또는 프로세스 번호 등
	- 입출력 상태 정보: 해당 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등
	_**프로세스 제어 블록은 약간의 회계 데이터와 함께 프로세스를 시작시키거나 다시 시작시키는데 필요한 모든 데이터를 위한 저장소의 역할을 한다.**_
<br>

- **스레드 Threads**
	대부분의 현대 운영체제는 프로세스 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용한다.

## 3.2 프로세스 스케줄링 Process Scheduling
다중 프로그램의 목적은 CPU이용을 최대화하기 위해 항상 어떤 프로세스가 실행되도록 하는 데 있다.
	각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU 코어를 빈번하게 교체하는 것이다. 이것을 위해 **프로세스 스케줄러**는 코어에서 실행 가능한 여러 프로세스 중 하나의 프로세스를 선택한다.
	각 CPU코어는 한 번에 하나의 프로세스를 실행할 수 있다. 코어보다 많은 프로세스가 있는 경우 초과 프로세스는 코어가 사용 가능해지고 다시 스케줄 될 때까지 기다린다. 현재 메모리에 있는 프로세스 수를 **다중 프로그래밍 정도**라고 한다.
	다중 프로그래밍 및 시간 공유의 목표를 균형 있게 유지하려면 프로셋스의 일반적인 동작을 고려해야 한다. I/O 바운드 프로세스는 계산에 소비하는 것보다 I/O에 더 많은 시간을 소비하는 프로세스이다. 반대로 CPU 바운드 프로세스는 계산에 더 많은 시간을 사용하여 I/O 요청을 자주 생성하지 않는다.
<br>
- **스케줄링 큐 Scheduling Queue**
	프로세스가 시스템에 들어가면 **준비 큐**에 들어가 준비 상태가 되어 CPU 코어에서 실행되기를 기다린다.
	프로세스에 CPU 코어가 할당되면 프로세스는 잠시 동안 실행되어 결국 종료되거나 인터럽트 되거나 I/O 요청의 완료와 같은 특정 이벤트가 발생할 때까지 기다린다. I/O 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스는 **대기 큐(wait queue)**에 삽입된다
	새 프로그램은 처음에 준비 큐에 놓인다. 프로세스는 실행을 위해 선택되거나 또는 **디스패치** 될 때까지 기다린다. 프로세스에 CPU 코어가 할당되고 실행 상태가 되면, 여러 이벤트 중 하나가 발생할 수 있다.
	- 프로세스가 I/O 요청을 공표한 다음 I/O 대기 큐에 놓일 수 있다.
	- 프로세스는 새 자식 프로세스를 만든 다음 자식의 종료를 기다리는 동안 대기 큐에 놓일 수 있다.
	- 인터럽트 또는 타임 슬라이스가 만료되어 프로세스가 코어에서 강제로 제거되어 준비 큐로 돌아갈 수 있다.
<br>

- __CPU 스케줄링 CPU Scheduling__
	CPU 스케줄러의 역할은 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU코어를 할당하는 것이다.
	일부 운영체제는 **스와핑** 으로 알려진 중간 형태의 스케줄링을 가지고 있는데, 핵심 아이디어는 가끔 메모리에서(및 CPU에 대한 능동적 경쟁에서) 프로세스를 제거하여 다중 프로그래밍의 정도를 감소시키는 것이다. 나중에 프로세스를 메모리에 다시 적재될 수 있으며 중단된 위치에서 실행을 계속할 수 있다. 일반적으로 스와핑은 메모리가 초과 사용되어 가용공간을 확보해야 할 때만 필요하다.
<br>

- **문맥 교환 Context Switch**
	인터럽트는 운영체제가 CPU 코어를 현재 작업에서 뺏어 내어 커널 루틴을 실행할 수 있게 한다. 이러한 연산은 범용 시스템에서는 자주 발생한다.
	인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 **문맥**을 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있다. 문맥은 프로세스의 PCB(3.1)에 표현된다.
	문맥은 CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등을 포함한다. 일반적으로 커널 모드이건 사용자 모드이건 CPU의 현재 상태를 저장하는 작업을 수행(state save)한 뒤 나중에 연산을 재개하기 위해 상태 복구 작업을 수행(state restore)한다.
	**문맥 교환**은 CPU 코어를 다른 프로세스로 교환하려면 이전 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이다.
	문맥 교환이 일어나면, 커널은 과거 프로세스의 문맥을 PCB에 저장하고, 실행이 스케줄된 새로운 프로세스의 저장된 문맥을 복구한다.
	*문맥 교환이 진행될 동안 시스템이 아무런 유용한 일을 못 하기 때문에 문맥 교환 시간은 순수한 오버헤드이다.*
## 3.3 프로세스에 대한 연산 Operation on Processes
대부분 시스템 내의 프로세스들은 병행 실행될 수 있으며, 반드시 동적으로 생성되고, 제거되어야 한다. 따라서 운영체제는 프로세스 생성 및 종료를 위한 기법을 제공해야 한다.
<br>
- **프로세스 생성 Process Creation**
	프로세스들은 여러 개의 새로운 프로세스들을 생성할 수 있다. 새로운 프로세스들은 각각 다시 다른 프로세스들을 생성할 수 있으며, 결과적으로 프로세스의 트리를 형성한다.
	대부분의 현대 운영체제들은 프로세스 식별자(pid)를 통해 프로세스를 구별한다. 이 식별자를 통하여 커널이 유지하고 있는 프로세스의 다양한 속성에 접근하기 위한 찾아보기(index)로 사용된다.
	**Linux의 경우**, 언제나 pid가 1인 systemd 프로세스가 모든 사용자 프로세스의 루트 부모 프로세스 역할을 수행하고 시스템이 부트될 때 생성되는 첫 번째 사용자 프로세스이다.
	시스템이 부팅되면 systemd프로세스는 다양한 사용자 프로세스를 생성한다. 이러한 프로세스에는 웹 또는 프린트 서버, ssh 서버 등이 포함된다. UNIX와 Linux 시스템에서는 ps명령어를 이용해 프로세스들의 목록을 얻을 수 있다(ps -el).
	프로세스가 새로운 프로세스를 생설 때, 두 프로세스를 실행시키는 데 두 가지의 가능한 방법이 있다.
	1. 부모는 자식과 병행하게 실행을 계속한다.
	2. 부모는 일부 또는 모든 자식이 실행을 종료할 때까지 기다린다.
	새로운 프로세스들의 주소 공간 측면에서 볼 때 다음과 같은 두 가지 가능성이 있다.
	1. 자식 프로세스는 부모 프로세스의 복사본이다(자식은 부모와 똑같은 프로그램과 데이터를 가진다).
	2. 자식 프로세스가 자신에게 적재될 새로운 프로그램을 가지고 있다.
```C
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>

int	main()
{
	pid_t	pid;

	pid = fork(); //새 프로세스를 생성

	if (pid < 0) //오류 발생
		return 1;
	else if (pid == 0) // 자식 프로세스
		execlp("/bin/ls", "ls", NULL);
	else
	{
		wait(NULL); // 부모가 자식이 완료되기를 기다린다.
		printf("Child Complete");
	}
	return 0;
}
```
&emsp;&emsp;**Windows의 경우**, Windows API의 CreateProcess() 함수를 이용하여 생성된다. 그러나 fork()가 부모 프로세스부터 주소 공간을 상속받는 자식 프로세스를 생성하는 반면에 CreateProcess()는 자식 프로세스가 생성될 때 주소 공간에 명시된 프로그램을 적재한다. 또한 fork()가 아무런 인자가 전달되지 않는 반면에 CreateProcess()는 10개 이상의 매개변수를 요구한다.
```C
#include <stdio.h>
#include <windows.h>

int	main()
{
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	//메모리 할당
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	//자식 프로세스 생성
	if (!CreateProcess(NULL, /*명령어 라인 사용*/
	"C:\\WINDOWS\\system32\\mspaint.exe", /*명령어 라인*/
	NULL, /*프로세스를 상속하지 말 것*/
	NULL, /*스레드 핸들을 상속하지 말 것*/
	FALSE, /*핸들 상속 디제이블*/
	0, /*생성 플래그 없음*/
	NULL, /*부모 환경 블록 사용*/
	NULL, /*부모 프로세스가 존재하는 디렉터리 사용*/
	&si,
	&pi))
	{
		fprintf(strderr, "Create Process Failed");
		return (-1);
	}
	/*부모 프로세스가 자식 프로세스의 종료를 기다림*/
	WaitForSingleObject(pi.hProcess, INFINITE);
	printf("Child Complete");

	/*핸들 닫기*/
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
}
```

- **프로세스 종료 Process Termination**
	프로세스가 마지막 문장의 실행을 끝내고, exit 시스템 콜을 사용하여 운영체제에 자신의 삭제를 요청하면 종료한다. 이 시점에서, 프로세스는 자신을 기다리고 있는 부모 프로세스에 상태값(통상 정수)를 반환할 수 있다.
	물리 메모리와 가상 메모리, 열린 파일, 입출력 버퍼를 포함한 프로세스의 모든 자원이 할당 해제되고 운영체제로 반납된다.
	부모는 여러 가지 이유로 인하여 자식 중 하나의 실행을 종료할 수 있다.
	- 자식이 자신에게 할당된 자원을 초과하여 사용할 때.
	- 자식에게 할당된 태스크가 더 이상 필요 없을 때.
	- 부모가 exit를 하는데, 운영체제는 부모가 exit한 후에 자식이 실행을 계속하는 것을 허용하지 않는 경우.

	몇몇 시스템에서는 프로세스가 종료되면 그로부터 비롯된 모든 자식 프로세스들도 종료되어야 한다. 이것을 **연쇄식 종료(cascading termination)** 이라 부르고 운영체재가 담당한다.
	프로세스가 종료하면 사용하던 자원은 운영체제가 되찾아 간다. 그러나 프로세스의 종료 상태가 저장되는 프로세스 테이블의 해당 항목은 부모 프로세스가 wait()을 호추할 때까지 남아 있게 된다.
	**좀비(zombie)** 프로세스는 종료되었지만 부모 프로세스가 wait()호출을 하지 않아 프로세스 테이블에 항목이 남아 있는 프로세스이다. 종료하게 되면 모든 프로세스는 좀비 상태가 되지만 아주 짧은 시간 동안만 머무른다.
	부모가 wait()을 호출하면 좀비 프로세스의 프로세스 식별자와 프로세스 테이블의 해당 항목이 운영체제에 반환된다.
	부모 프로세스가 wait()을 호출하는 대신 종료한다면 남게된 자식 프로세스를 **고아(orphan)** 프로세스라고 부른다.
	전통적인 UNIX는 고아 프로세스의 새로운 부모 프로세스로 init 프로세스를 지정함으로써 이 문제를 해결한다. init 프로세스는 주기적으로 wait()를 호출해 고아 프로세스의 종료 상태를 수집, 프로세스 식별자와 프로세스 테이블 항목을 반환한다.
	대부분의 Linux 시스템은 init 을 systemd로 대체하였다. Linux는 systemd 이외의 프로세스가 고아 프로세스를 상속하고 종료를 관리하도록 허용한다.
<br>

## 3.4 프로세스 간 통신 Interprocess Communication
- 독립적 프로세스: 프로세스가 시스템에서 실행 중인 다른 프로세스들과 데이터를 공유하지 않는 프로세스
- 협력적 프로세스: 프로세스가 시스템에서 실행 중인 다른 프로세스들에 영향을 주고받는 프로세스
프로세스간 협력을 허용하는 이유
	- 정보 공유(information sharing)
	- 계산 가속화(computation speedup)
	- 모듈성(modularity)
협력적 프로세스는 **프로세스 간 통신(interprocess communication, IPC)** 기법이 필요하다.
프로세스간 통신에는 기본적으로 공유 메모리(shared memory)와 메시지 전달(message passing) 두 가지 모델이 있다.
<br>

## 3.5 공유 메모리 시스템에서의 프로세스 간 통신 IPC in Shared-Memory Systems
공유 메모리 시스템을 사용하는 프로세스들은 공유 메모리 영역을 구축해야 한다.
- 생산자-소비자 문제
- 무한 버퍼(unbounded buffer)와 유한 버퍼(boundeed buffer)
<br>

## 3.6 메시지 전달 시스템에서의 프로세스 간 통신 IPC in Message-Passing Systems
메시지 전달 시스템은 최소한 sand(message)와 receive(message)연산을 제공한다.
하나의 링크와 send()/receive() 연산을 논리적으로 구현하는 방법
	- 직접 또는 간접 통신
	- 동기식 또는 비동기식 통신
	- 자동 또는 명시적 버퍼링

- **명명 Naming**

직접 통신하에서, 통신을 원하는 각 프로세스는 통신의 수신자 또는 송신자의 이름을 명시해야 한다.
- send(P, message) -프로세스 P에 메시지 전송
- receive(Q, message) -프로세스 Q로부터 메시지를 수신
이 기법에서 통신 연결은 다음의 특성을 가진다
	- 통신을 원하는 각 프로세스의 쌍들 사이에 연결이 자동으로 구축된다. 프로세스ㅡㄹ은 통신하기 위해ㅐ 상대방의 신원(identity)만 알면 된다.
	- 연결은 정확히 두 프로세스 사이에만 연관된다.
	- 통신하는 프로세스들의 각 쌍 사이에는 정확하게 하나의 연결이 존재해야 한다.

간접 통신에서 메시지들은 **메일박스(mailbox)** 또는 **포트(port)** 로 송신되고, 그것으로부터 수신된다.
- send(A, message) 메시지를 메일박스 A로 송신한다.
- receive(A, message) 메시지를 메일박스 A로부터 수신한다.
이 기법에서 통신 연결은 다음의 특성을 가진다
	- 한 쌍의 프로세스들 사이의 연결은 이들 프로세스가 공유 메일박스를 가질 때만 구축된다.
	- 연결은 두 개 이상의 프로세스들과 연관될 수 있다.
	- 통신하고 있는 각 프로세스 사이에는 다수의 서로 다른 연결이 존재할 수 있고, 각 연결은 하나의 메일박스에 대응된다.

- **동기화 Synchronization**
메시지 전달은 **봉쇄형(blocking)** 또는 **비봉쇄형(nonblocking)** 방식으로 전달된다. 이 두 방식은 각각 **동기식** **비동기식**이라고도 알려져 있다.
	- 봉쇄형 보내기: 송신하는 프로세스는 메시지가 수신 프로세스 또는 메일박스에 의해 수신될 때가지 봉쇄된다.
	- 비봉쇄형 보내기: 송신하는 프로세스가 메시지를 보내고 작업을 재시작한다.
	- 봉쇄형 받기: 메시지가 이용 가능할 때까지 수신 프로세스가 봉쇄된다.
	- 비봉쇄형 받기: 송신하는 프로세스가 유효한 메시지 또는 널(null)을 받는다.

- **버퍼링 Buffering**
통신이 직접적이든 간접적이든 간에, 통신하는 프로세스들에 의해 교환되는 메시지는 임시 큐에 들어 있다. 이 큐를 구현하는 방식은 세 가지가 있다.
	- 무용량(zero capacity): 큐의 최대 길이가 0이다. 즉, 링크는 자체 안에 대기하는 메시지들을 가질 수 없다. 이 경우에, 송신자는 수신자가 메시지를 수신할 때까지 기다려야 한다.
	- 유한 용량(bounded capacity): 큐는 유한한 길이 n을 가진다. 새로운 메시지가 전송될 때 큐가 만원이 아니라면, 메시지는 큐에 놓이며, 송신자는 대기하지 않고 실행을 계속한다. 링크는 유한한 용량을 가진다. 링크가 만원이면, 송신자는 큐 안에 공간이 이용 가능할 때까지 반드시 봉쇄되어야 한다.
	- 무한 용량(unbounded capacity): 큐는 잠재적으로 무한한 길이를 가진다. 따라서 메시지들이 얼마든지 큐 안에서 대기할 수 있다. 송신자는 절대 봉쇄되지 않는다.

## 3.7 IPC 시스템의 사례 Examples of IPC Systems

- **파이프 pipes**
파이프는 두 프로세스가 통신할 수 있게 하는 전달자로서 동작한다. 파이프를 구현하기 위해서는 다음 4가지를 고려해야 한다.
	- 파이프가 단방향 통신 또는 양방향 통신을 허용하는가?
	- 양방향 통신이 허용된다면 반이중(half duplex) 방식인가, 전이중(full duplex)방식인가? 반이중 방식은 한순간에 한방향 전송만 가능하고, 전이중 방식은 동시에 양방향 전송이 가능하다.
	- 통신하는 두 프로세스 간에 **부모-자식**과 같은 특정 관계가 존재해야만 하는가?
	- 파이프는 네트워크를 통하여 통신이 가능한가, 아니면 동일한 기계 안에 존재하는 두 프로세스끼리만 통신할 수 있는가?

**일반 파이프**

## 3.8 클라이언트 서버 환경에서 통신 Communication in Client-Server Systems

- **소켓 sockets**

