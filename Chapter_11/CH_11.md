### 챕터 11 요약
- 하드 디스크 드라이브 및 비휘발성 메모리 장치는 대부분의 컴퓨터에서 주요 보조저장장치 I/O 장치이다. 최신 보조저장장치는 논리 블록의 1차원 배열로 구성된다.
- 두 유형 중 하나의 드라이브는 다음 세 가지 방법의 하나로 컴퓨터 시스템에 연결된다. (1) 호스트 컴퓨터의 로컬 I/O포트를 통해 (2) 마더보드에 직접 연결 (3) 통신 네트워크 또는 스토리지 네트워크 연결
- 보조저장장치 I/O요청은 파일 시스템과 가상 메모리 시스템에 의해 생성된다. 각 요청은 논리 블록 번호 형식으로 참조할 장치의 주소를 지정한다.
- 디스크 스케줄링 알고리즘은 HDD의 유효 대역폭, 평균 응답 시간 및 응답 시간의 편차를 향상할 수 있다. SCAN 및 C-SCAN과 같은 알고리즘은 디스크 큐 순서를 위한 전략을 통해 이러한 기능을 향상하도록 설계되었다. 디스크 스케줄링 알고리즘의 성능은 하드 디스크에서 크게 다를 수 있다. 대조적으로, 반도체 디스크에는 움직이는 부분이 없으므로 스케줄링 알고리즘마다 성능이 거의 다르지 않으며 간단한 FCFS 전략이 사용되는 경우가 많다.
- 데이터 저장 및 전송은 복잡하고 종종 오류가 발생한다. 오류 감지는 그러한 문제를 발견하여 시스템에 보고하여 수정 조치를 하게 하고 오류의 전파를 방지한다. 오류 수정은 사용 가능한 수정 데이터 양과 손상된 데이터 양에 따라 문제를 감지하고 복구할 수 있다.
- 저장장치는 하나 이상의 공간으로 파티션된다. 각 파티션은 볼륨을 보유하거나 다중 장치 볼륨의 일부일 수 있다. 파일 시스템은 볼륨 안에 생성된다.
- 운영체제는 저장장치의 블록을 관리한다. 새로운 장치는 일반적으로 사전 포맷되어 제공된다. 장치가 파티션되고 파일 시스템이 생성되며 장치에 운영체제가 포함된 경우 시스템의 부트스트랩 프로그램을 저장하기 위해 부트 블록이 할당된다. 마지막으로, 블록 또는 페이지가 손상되면 시스템은 해당 블록을 퇴출하고 여분의 블록 또는 페이지로 논리적으로 대체할 방법이 있어야 한다.
- 효율적인 스왑 공간은 일부 시스템에서 성능을 향상하는 열쇠이다. 일부 시스템은 스왑 공간으로 raw 파티션을 할당하고 다른 시스템은 파일 시스템 내의 파일을 대신 사용한다. 여전히 다른 시스템에서는 사용자나 시스템 관리자에게 두 가지 옵션을 모두 제공하여 결정을 내릴 수 있게 한다.
- 대규모 시스템에 필요한 저장장치 양과 저장장치가 여러 가지 방식으로 실패하기 때문에 보조저장장치는 종종 RAID 알고리즘을 통해 중복된다. 이 알고리즘을 사용하면 주어진 작업에 둘 이상의 드라이브를 사용할 수 있으며 드라이브 고장 시에도 지속적인 작업과 자동 복구가 가능하다. RAID 알고리즘은 여러 수준으로 구성된다. 각 레벨은 신뢰성과 높은 전송 속도의 조합을 제공한다.
- 객체 저장소는 인터넷 및 클라우드 사진 저장소 인덱싱과 같은 빅데이터 문제에 사용된다. 객체는 파일 이름이 아닌 객체 ID로 지정되는 자체 정의 데이터 모음이다. 일반적으로 데이터 보호를 위해 복제를 사용하고, 데이터 사본이 존재하는 시스템에서 데이터 기반 연산을 하며, 대용량으로 쉽게 확장할 수 있도록 수평으로 확장 가능하다.

### 이 장의 목표
- 다양한 보조저장장치의 물리적 구조와 장치 구조가 활용에 미치는 영향을 설명한다.
- 대용량 저장장치의 성능 특성을 설명한다.
- I/O 스케줄링 알고리즘을 평가한다.
- RAID를 포함하여 대용량 저장장치를 위해 제공되는 운영체제 서비스에 대해 논의한다.

## 11.1 대용량 저장장치 구조의 개관
최신 컴퓨터를 위한 대량의 보조저장장치는 **하드 디스크 드라이브(HDD)** 및 **비휘발성 메모리(NVM)** 장치에 의해 제공된다. 이 절에서는 이러한 장치의 기본 기법을 설명하고 운영체제가 주소 매핑을 통해 물리적 속성을 논리 저장장치로 변환하는 방법을 설명한다.

- **하드 디스크 드라이브**
각 디스크의 **플래터(platter)** 는 CD처럼 생긴 원형 평판 모양이다. 우리는 정보를 플래터상에 자기적으로 기록하여 저장하고 플래터의 자기 패턴을 감지하여 정보를 읽는다(그림 11.1).
읽기-쓰기 헤드는 모든 플래터의 각 표면 바로 위에서 '움직인다'. 헤드는 모든 헤드를 한꺼번에 이동시키는 **디스크 암(disk arm)** 에 부착되어 있다. 플래터의 표면은 원형인 **트랙(track)** 으로 논리적으로 나누어져 있다. 동일한 암 위치에 있는 트랙의 집합은 하나의 **실린더(cylinder)** 를 형성한다.
디스크 드라이브 모터는 고속으로 회전한다. 회전 속도는 전송 속도와 관련이 있다. **전송 속도** 는 드라이브와 컴퓨터 간의 데이터 흐름의 속도이다. 또 다른 성능 측면인 **위치 지정 시간** 또는 **임의 액세스 시간** 은 두 부분으로 구성된다. 디스크 암을 원하는 실린더로 이동하는데 필요한 시간(**탐색 시간**)과 원하는 섹터가 디스크 헤드 위치까지 회전하는데 걸리는 시간(**회전 지연시간**)이다. 일반적인 디스크는 초당 수백메가바이트의 데이터를 전송할 수 있으며 수 밀리초 정도의 탐색 시간과 회전 지연 시간을 가진다. 드라이브 컨트롤러에 DRAM 버퍼를 사용하여 성능을 향상한다.
헤드는 때때로 자기 표면을 손상시키는데, 이를 **헤드 충돌**이라 한다. 헤드 충돌은 일반적으로 수리할 수 없고 디스크의 데이터가 다른 저장장치나 RAID로 보호하지 않은 경우 손실된다.
<br>

- **비휘발성 메모리 장치**
비휘발성 메모리(NVM) 장치의 중요성이 증가하고 있다. 간단히 말해 NVM 장치는 기계식이 아니라 전기식이다.
플래시 메모리 기반 NVM은 디스크 드라이브와 유사한 컨테이너에서 자주 사용되며 이 경우 SSD(solid-state disk)라고 한다. 다른 경우에는 USB 드라이브 또는 DRAM 스틱의 형태를 취한다.
NVM 장치는 움직이는 부품이 없으므로 HDD보다 안정성이 높으며 탐색 시간이나 회전 지연시간이 없으므로 더 빠르고 전력 소비량도 적다. 하지만 기존 하드 디스크보다 용량이 적은데 비용은 더 비싸다.
**가비지 수집**은 유효한 데이터와 유효하지 않은 페이지가 공존하는 NAND 블록에서 유효한 데이터를 다른 위치로 복사하여 지울 수 있는 블록을 비운 다음 쓰기를 받아들이는 것이다. 이때 유효한 데이터를 저장하기 위한 공간은 **과잉 공급(over-provisioning)** 을 사용한다. 장치는 언제나 쓸 수 있도록 다수의 페이지를 따로 준비해 놓는 것이다. 이는 장치의 전체 블록들의 수명을 비슷하게 유지시키는 **마모 평준화(wear leveling)** 에도 도움이 된다.
<br>

- **휘발성 메모리**
RAM 드라이브는 고속 임시 저장 공간으로 유용하다. NVM장치는 빠르지만 DRAM은 훨씬 빠르며 RAM 드라이브에 대한 I/O 작업은 파일과 내용을 생성, 읽기, 쓰기 및 삭제하는 가장 빠른 방법이다.
<br>

- **보조저장장치 연결 방법**
보조저장장치는 시스템 버스 또는 I/O 버스에 의해 컴퓨터에 연결된다.
`ATA(Advanced Technology attachment)`, `SATA(serial ATA)`, `eSATA`, `SAS(serial attached SCSI)`, `USB(universal serial bus)` 및 `FC(fiber channel)`을 포함하여 여러 종류의 버스를 사용할 수 있다.
버스에서의 데이터 전송은 **컨트롤러**[또는 `호스트 버스 어댑터(HBA)`]라고 하는 특수 전자 프로세서에 의해 수행된다. **호스트 컨트롤러**는 버스의 컴퓨터 쪽에 있는 컨트롤러아다. 각 저장장치에는 **장치 컨트롤러**가 내장되어 있다.
<br>

- **주소 매핑**
저장장치는 `논리 블록(가장 작은 전송 단위)`의 커다란 1차원 배열처럼 주소가 매겨진다. 각 논리 블록은 물리 색터 또는 반도체 페이지로 매핑된다.

## 11.2 디스크 스케줄링
운영체제의 책임 중 하나는 효율적인 하드웨어 사용이다. HDD의 경우 이 책임은 접근 공간을 최소화하고 전송 대역폭을 최대화하는 것을 수반한다.
기계식 저장장치의 경우:
- 탐색 시간(seek time). 장치 암이 헤드를 해당 실린더로 움직이는 데 걸리는 시간
- 회전 지연(rotational latency)시간. 플래터가 원하는 섹터를 헤드 위치까지 회전시키는 데 소요되는 추가적인 시간
- 장치 대역폭. 전송된 총 바이트 수를 첫 번째 서비스 요청과 마지막 전송 완료 사이의 전체 시간으로 나눈 값

프로세스가 입출력을 해야 할 때마다 운영체제에 시스템 콜을 한다. 이때 여러 가지의 인수가 주어진다.
- 이 작업이 입력 또는 출력인지의 여부
- 연산이 수행될 파일을 가리키는 열린 파일 핸들
- 전송을 위한 메모리 주소
- 전송할 데이터의 양

과거 HDD 인터페이스에서는 호스트가 사용할 트랙과 헤드를 지정해야 했으며 디스크 스케줄링 알고리즘에 큰 노력을 기울였다. 2000년 이후의 새로운 드라이브는 이러한 컨트롤을 호스트에 노출하지 않을 뿐 아니라 LBA를 물리적 주소로 매핑하는 책임이 드라이브에 있다.

- **선입 선처리 스케줄링**
입출력 요청을 들어오는 순서대로 처리해준다. 간단하지만 빠르지 못하다.
<br>

- **SCAN 스케줄링**
**SCAN 알고리즘**에서는 디스크 암(disk arm)이 디스크의 한끝에서 시작하여 다른 끝으로 이동하며, 가는 길에 있는 요청을 모두 처리한다. 다른 한쪽 끝에 도달하면 역방향으로 이동하면서 오는 길에 있는 요청을 모두 처리한다. 엘리베이터 알고리즘이라고도 불린다.
<br>

- **C-SCAN 스케줄링**
**C-SCAN (circular-SCAN) 알고리즘**은 각 요청에 걸리는 시간을 좀 더 균등하게하기 위한 SCAN의 변형이다.
SCAN과 같이 한쪽으로 헤드를 이동해 가면서 요청을 처리하지만, 한쪽 끝에 다다르면 처음 시작했던 자리로 다시 돌아가 서비스를 시작한다.
<br>

- **디스크 스케줄링 알고리즘의 선택**
SCAN 및 C-SCAN은 기아 문제를 일으킬 가능성이 작기 때문에 디스크에 많은 부하를 주는 시스템의 성능을 향상한다.
그래도 기아가 계속될 수 있으며, 이로 인해 Linux가 **마감시간(deadline)** 스케줄러를 만들었다. 이 스케줄러는 읽기와 쓰기별로 큐를 유지 관리하며 프로세스가 쓸 때보다 읽을 때 봉쇄될 가능성이 높으므로 읽기 연산에 높은 우선순위를 준다.
RHEL 7에는 NVM 장치와 같은 빠른 저장장치를 사용하는 CPU-중심 시스템에 선호되며 **CFQ (completely fair queuing) 스케줄러**는 SATA 드라이버의 디폴트 스케줄러이다.

## 11.3 NVM 스케줄링

## 11.4 오류 감지 및 수정
페리티 비트

## 11.5 저장장치 관리

- **드라이브 포매칭, 파티션, 볼륨**
저장장치는 자료를 저장하기 전에 컨트롤러가 읽고 쓸 수 있도록 섹터들로 나누어져 있어야 한다.
NVM페이지는 초기화되어야 하고 FTL이 생성되어야 한다. 이 과정을 **저수준 포매팅(low-level formatting)** 또는 **물리적 포매팅** 이라고 한다.
저수준 포매팅은 각 저장장치 위치마다 특별한 자료구조로 장치를 채운다. 섹터 또는 페이지를 위한 자료구조는 보통 `헤더(header)`, `자료 구역(data area)`와 `트레일러(trailer)`로 구성된다.
드라이브를 사용하여 파일을 보유하려면 운영체제가 여전히 자체 데이터 구조를 장치에 기록해양 한다. 운영체제는 이 작업을 세 단계로 수행한다.
첫 번째로 장치를 하나 이상의 블록 또는 페이지 그룹으로 **파티션**하는 것이다. 운영체제는 각 파티션을 별도의 장치인 것처럼 취급할 수 있다. 파티션 정보는 저장장치의 고정된 위치에 고정된 형식으로 기록된다.
두 번째 단계는 **볼륨** 생성 및 관리이다. 파일 시스템이 파티션 내에 직접 배치될 때와 같이 이 단계는 암시적으로 적용된다. 그러면 해당 볼륨을 마운트하여 사용할 수 있다. 다른 경우에는 볼륨 생성 및 관리가 명시적으로 행해진다.
세 번째 단계는 **논리적 포매팅** 또는 파일 시스템의 생성이다. 이 단계에서 운영체제는 초기 파일 시스템 자료구조를 장치에 저장한다. 이러한 자료구조에는 가용 공간과 할당된 공간의 맵과 초기의 빈 디렉터리 등이 포함된다.
